// var maze = new Phaser.Game( 800, 600, Phaser.AUTO, "maze", { preload: preload, create: create, update: update, render: render }, false );
//
// var isoGroup, cursors, walls;
//
// function preload () {
//   maze.load.tilemap( 'floor', '<%= asset_path( "assets/mazeup_Floor.csv" ) %>', null, Phaser.Tilemap.CSV );
//   maze.load.image( 'tile', '<%= asset_path( "assets/stone_n.png" ) %>' );
//   maze.load.image( 'wall', '<%= asset_path( "assets/stonewall_n.png" ) %>' );
//   maze.load.spritesheet('hero', '<%= asset_path("assets/hero.png") %>', 45, 48);
//
//   maze.time.advancedTiming = true;
//
//   // Add and enable the plug-in.
//   maze.plugins.add( new Phaser.Plugin.Isometric( maze ) );
//
//   // Start the IsoArcade physics system.
//   maze.physics.startSystem(Phaser.Plugin.Isometric.ISOARCADE);
//
//   // This is used to set a maze canvas-based offset for the 0, 0, 0 isometric coordinate - by default
//   // this point would be at screen coordinates 0, 0 (top left) which is usually undesirable.
//   maze.iso.anchor.setTo(0.5, 0.2);
// }
//
//
// function create () {
//   isoGroup = maze.add.group();
//   walls = maze.add.group();
//
//
//   var tileArray = [];
//   var tiles = [
//                 4, 4, 4, 4, 4, 5, 4, 4, 4, 8,
//                 10, -1, -1, -1, 8, -1, 8, 1, -1, 6,
//                 10, -1, 6, -1, 8, 9, 9, 9, -1, 2,
//                 10, -1, 3, 1, 0, -1, 0, -1, -1, 6,
//                 7, 4, -1, -1, -1, -1, -1, -1, -1, 8,
//                 10, -1, -1, 4, 4, 7, 6, 9, -1, 6,
//                 10, -1, 3, -1, -1, 7, -1, -1, -1, 8,
//                 4, 4, 4, -1, -1, -1, -1, 9, 9, 9,
//                 7, -1, -1, -1, 7, 9, 9, 7, -1, 8,
//                 10, 0, 4, 4, -1, -1, -1, -1, -1, 8
//               ];
//
//   var size = 16;
//
//   var i = 0, tile;
//   for (var y = size; y <= maze.physics.isoArcade.bounds.frontY - ( Math.abs( size ) ); y += ( Math.abs(size) ) ) {
//       for (var x = size; x <= maze.physics.isoArcade.bounds.frontX - ( Math.abs( size ) ); x += ( Math.abs( size ) ) ) {
//           tile = maze.add.isoSprite( x, y, 0, "tile", null, isoGroup );
//           tile.anchor.set( 0.5, 0.5 );
//           tile.smoothed = false;
//       }
//   }
//
//   // Let's make a load of cubes on a grid, but do it back-to-front so they get added out of order.
//   var wall;
//   for (var xx = 300; xx > 0; xx -= 80) {
//       for (var yy = 300; yy > 0; yy -= 80) {
//           // Create a wall using the new game.add.isoSprite factory method at the specified position.
//           // The last parameter is the group you want to add it to (just like game.add.sprite)
//           wall = maze.add.isoSprite( xx, yy, 3, 'wall', 0, walls );
//           wall.anchor.set(0.5);
//
//           // Enable the physics body on this wall.
//           maze.physics.isoArcade.enable( wall );
//           wall.body.immovable = true;
//
//
//           // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
//           // wall.body.collideWorldBounds = true;
//           //
//           // // Add a full bounce on the x and y axes, and a bit on the z axis.
//           // wall.body.bounce.set(0, 0, 0);
//           //
//           // // Add some X and Y drag to make walls slow down after being pushed.
//           // wall.body.drag.set(0, 0, 0);
//       }
//   }
//
//
//   player = maze.add.isoSprite(128, 128, 1, 'hero', 4);
//
//   //  Our two animations, walking left and right.
//   player.animations.add('right', [0, 1, 2, 3], 10, true);
//   player.animations.add('left', [5, 6, 7, 8], 10, true);
//
//   console.log( player.animations );
//   player.name = "player";
//
//
//   player.anchor.set( 0.5 );
//   maze.physics.isoArcade.enable( player );
//   player.body.collideWorldBounds = true;
//
//   cursors = maze.input.keyboard.createCursorKeys();
//
//   maze.input.keyboard.addKeyCapture([
//       Phaser.Keyboard.LEFT,
//       Phaser.Keyboard.RIGHT,
//       Phaser.Keyboard.UP,
//       Phaser.Keyboard.DOWN,
//       Phaser.Keyboard.SPACEBAR
//   ]);
//
// }
//
// function update () {
//   maze.physics.isoArcade.collide( player, walls, function () { console.log( "Collided" ); } );
//
//   // Move the player at this speed.
//   var speed = 100;
//
//   if ( cursors.up.isDown ) {
//     player.body.velocity.y = -speed;
//   }
//   else if ( cursors.down.isDown ) {
//     player.body.velocity.y = speed;
//   }
//   else {
//     player.body.velocity.y = 0;
//   }
//
//   if ( cursors.left.isDown ) {
//     player.body.velocity.x = -speed;
//     player.animations.play('left');
//   }
//   else if ( cursors.right.isDown ) {
//     player.body.velocity.x = speed;
//     player.animations.play('right');
//   }
//   else {
//     player.body.velocity.x = 0;
//     player.animations.stop();
//     player.frame = 4;
//   }
//
// }
//
// function render () {
//
// }
