// The arguments
// 1. width
// 2. height
// 3. renderer ( Phaser.AUTO, Phaser.CANVAS, Phaser.WEBGL or Phaser.HEADLESS for no rendering at all )
// 4. parent ( To specify which element that it will append to. Takes in the ID of the element )
// 5. State of it during on create ( null, preload, create, update, render )
// 6. Transparent ( referring to the background whether to have a transparent or not )
// 7. Antialias ( Drawing of the image texture. Default is true unless if you're going to have pixel art, then go for false )
// 8. physicsConfig ( Physics configuration object to pass to the Physics world upon creation )
var ghost = new Phaser.Game( 800, 600, Phaser.AUTO, "ghost", { preload: preload, create: create, update: update, render: render }, true );

var cursors;

function preload () {
    ghost.load.image( 'ghostly', '<%= asset_path( "assets/clown.png" ) %>' );
    ghost.load.image( 'player', '<%= asset_path( "assets/master.png" ) %>' );

    ghost.time.advancedTiming = true;

    // Add and enable the plug-in.
    ghost.plugins.add(new Phaser.Plugin.Isometric(ghost));

    // Start the IsoArcade physics system.
    ghost.physics.startSystem(Phaser.Plugin.Isometric.ISOARCADE);

    // This is used to set a ghost canvas-based offset for the 0, 0, 0 isometric coordinate - by default
    // this point would be at screen coordinates 0, 0 (top left) which is usually undesirable.
    ghost.iso.anchor.setTo(0.5, 0.2);

};

function create () {
    // Create a group for our tiles, so we can use Group.sort
    isoGroup = ghost.add.group();


    // Set the global gravity for IsoArcade.
    ghost.physics.isoArcade.gravity.setTo(0, 0, -500);

    // Let's make a load of cubes on a grid.
    spawnGhosts();

    // Create another cube as our 'player', and set it up just like the cubes above.
    player = ghost.add.isoSprite(128, 128, 0, 'player', 0, isoGroup);
    player.name = "sifu";

    player.anchor.set(0.5);
    ghost.physics.isoArcade.enable(player);
    player.body.collideWorldBounds = true;

    // Allow the user to spawn another set of cubes each time they click/tap.
    ghost.input.onDown.add(function () {
        spawnGhosts();
    }, this);

    // Set up our controls.
    cursors = ghost.input.keyboard.createCursorKeys();

    ghost.input.keyboard.addKeyCapture([
        Phaser.Keyboard.LEFT,
        Phaser.Keyboard.RIGHT,
        Phaser.Keyboard.UP,
        Phaser.Keyboard.DOWN,
        Phaser.Keyboard.SPACEBAR
    ]);

    // var space = ghost.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
    //
    // space.onDown.add(function () {
    //     player.body.velocity.z = 300;
    // }, this);
};

function update () {

  // Move the player at this speed.
  var speed = 100;

  if ( cursors.up.isDown) {
      player.body.velocity.y = -speed;
  }
  else if (cursors.down.isDown) {
      player.body.velocity.y = speed;
  }
  else {
      player.body.velocity.y = 0;
  }

  if (cursors.left.isDown) {
      player.body.velocity.x = -speed;
  }
  else if (cursors.right.isDown) {
      player.body.velocity.x = speed;
  }
  else {
      player.body.velocity.x = 0;
  }

  // Just like Arcade Physics!
  ghost.physics.isoArcade.collide(isoGroup, player, function ( iso, player )
                                                    { console.log( "A => " + iso.name, player.name ); player.kill(); } );

  // Ensure everything stays sorted as it moves about. We'll use advanced sorting here as we're dealing with z axis stuff.
  ghost.iso.topologicalSort(isoGroup);

  // ghost.physics.arcade.overlap( player, isoGroup, function ( player, ghost ) { console.log(ghost); ghost.kill(); }, null, this );


};

function render () {
  ghost.debug.text("Click to spawn more cubes!", 2, 36, "#ffffff");
  ghost.debug.text(ghost.time.fps || '--', 2, 14, "#a7aebe");

  // Uncomment this to see the debug bodies.
  // isoGroup.forEach(function (currentCube) {
  //     ghost.debug.body(currentCube);
  // });
  //

  // isoGroup.forEach(function (ghostly) {
  //     if (ghostly.inCamera) {
  //         ghost.debug.body(ghostly, null, true, true);
  //     }
  // }, this);

  // game.debug.octree(game.physics.isoArcade.octree);
};

var spawnGhosts = function () {
    var ghostly;
    // for (var xx = 256; xx > 0; xx -= 64) {
        // for (var yy = 256; yy > 0; yy -= 64) {
            // Create a ghostly using the new game.add.isoSprite factory method at the specified position.
            // The last parameter is the group you want to add it to (just like game.add.sprite)
            ghostly = ghost.add.isoSprite(50, 50, 400, 'ghostly', 0, isoGroup);
            ghostly.name = "mirror";
            ghostly.anchor.set(0.5);

            // Enable the physics body on this ghostly.
            ghost.physics.isoArcade.enable(ghostly);

            // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
            ghostly.body.collideWorldBounds = true;

            // Add a full bounce on the x and y axes, and a bit on the z axis.
            ghostly.body.bounce.set(1, 1, 0.2);

            // Send the ghostlys off in random x and y directions! Wheee!
            ghostly.body.velocity.setTo(ghost.rnd.integerInRange(-50, 50), ghost.rnd.integerInRange(-50, 50), 0);
        // }
    // }
};

// game.state.add('Boot', BasicGame.Boot);
// game.state.start('Boot');
