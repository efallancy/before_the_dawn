// The arguments
// 1. width
// 2. height
// 3. renderer ( Phaser.AUTO, Phaser.CANVAS, Phaser.WEBGL or Phaser.HEADLESS for no rendering at all )
// 4. parent ( To specify which element that it will append to. Takes in the ID of the element )
// 5. State of it during on create ( null, preload, create, update, render )
// 6. Transparent ( referring to the background whether to have a transparent or not )
// 7. Antialias ( Drawing of the image texture. Default is true unless if you're going to have pixel art, then go for false )
// 8. physicsConfig ( Physics configuration object to pass to the Physics world upon creation )
var ghost = new Phaser.Game( 1200, 600, Phaser.AUTO, "ghost", { preload: preload, create: create, update: update, render: render }, true );

var cursors, ghosts, spawned = 0;
var hasCreatedOwnGhost = false;

function preload () {
    ghost.load.image( 'ghostly', '<%= asset_path( "assets/clown.png" ) %>' );
    ghost.load.image( 'player', '<%= asset_path( "assets/master.png" ) %>' );

    ghost.time.advancedTiming = true;

    // Add and enable the plug-in.
    ghost.plugins.add(new Phaser.Plugin.Isometric(ghost));

    // Start the IsoArcade physics system.
    ghost.physics.startSystem(Phaser.Plugin.Isometric.ISOARCADE);

    // This is used to set a ghost canvas-based offset for the 0, 0, 0 isometric coordinate - by default
    // this point would be at screen coordinates 0, 0 (top left) which is usually undesirable.
    ghost.iso.anchor.setTo(0.5, 0.2);

};

function create () {

    ghosts = ghost.add.group();

    // Set the global gravity for IsoArcade.
    ghost.physics.isoArcade.gravity.setTo( 0, 0, -500 );

    // Let's make a load of cubes on a grid.
    spawnGhosts();

    player = ghost.add.isoSprite( 128, 128, 0, 'player' );
    player.name = "player";

    player.anchor.set( 0.5 );
    ghost.physics.isoArcade.enable( player );
    player.body.collideWorldBounds = true;

    // Allow the user to spawn another set of cubes each time they click/tap.
    ghost.input.onDown.add( function () {
        spawnGhosts();
    }, this);

    // Set up our controls.
    cursors = ghost.input.keyboard.createCursorKeys();

    ghost.input.keyboard.addKeyCapture([
        Phaser.Keyboard.LEFT,
        Phaser.Keyboard.RIGHT,
        Phaser.Keyboard.UP,
        Phaser.Keyboard.DOWN,
        Phaser.Keyboard.SPACEBAR
    ]);

    // var space = ghost.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
    //
    // space.onDown.add(function () {
    //     player.body.velocity.z = 300;
    // }, this);
};

function update () {

  // Move the player at this speed.
  var speed = 100;

  if ( cursors.up.isDown ) {
      player.body.velocity.y = -speed;
  }
  else if ( cursors.down.isDown ) {
      player.body.velocity.y = speed;
  }
  else {
      player.body.velocity.y = 0;
  }

  if ( cursors.left.isDown ) {
      player.body.velocity.x = -speed;
  }
  else if ( cursors.right.isDown ) {
      player.body.velocity.x = speed;
  }
  else {
      player.body.velocity.x = 0;
  }

  // Just like Arcade Physics!
  ghost.physics.isoArcade.collide( ghosts, player, mirrorMyself );

  // Ensure everything stays sorted as it moves about. We'll use advanced sorting here as we're dealing with z axis stuff.
  ghost.iso.topologicalSort( ghosts );

};

function render () {
  ghost.debug.text("Knock over the clown to find your own ghost!", 2, 36, "#ff2222");
  ghost.debug.text(ghost.time.fps || '--', 2, 14, "#a7aebe");

  // Uncomment this to see the debug bodies.
  // isoGroup.forEach(function (currentCube) {
  //     ghost.debug.body(currentCube);
  // });
  //

  // isoGroup.forEach(function (ghostly) {
  //     if (ghostly.inCamera) {
  //         ghost.debug.body(ghostly, null, true, true);
  //     }
  // }, this);

  // game.debug.octree(game.physics.isoArcade.octree);
};

var mirrorMyself = function ( player, ghost ) {
  console.log( "Ghosts:", ghost.name );
  console.log( "Player:", player.name );

  if ( ghost.name !== player.name ) {
    // ghosts.forEach( function ( g ) {
    //   g.kill();
    // } );
    ghost.kill();
    spawned++;
    if ( spawned === 10 ) {
      spawnLittle();
      spawned = 0;
    }

  } else {
    ghosts.forEach( function ( g ) {
      g.kill();
    } );
  }

};

var spawnGhosts = function () {
    var ghostly;
    for (var xx = 256; xx > 0; xx -= 30 ) {
        for (var yy = 256; yy > 0; yy -= 30) {
            // Create a ghostly using the new game.add.isoSprite factory method at the specified position.
            // The last parameter is the group you want to add it to (just like game.add.sprite)
            ghostly = ghost.add.isoSprite(50, 50, 400, 'ghostly', 0, ghosts);

            if ( !hasCreatedOwnGhost ) {
              hasCreatedOwnGhost = true;
              ghostly.name = "player";
            }

            ghostly.anchor.set(0.5);

            // Enable the physics body on this ghostly.
            ghost.physics.isoArcade.enable(ghostly);

            // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
            ghostly.body.collideWorldBounds = true;

            // Add a full bounce on the x and y axes, and a bit on the z axis.
            ghostly.body.bounce.set(1, 1, 0.2);

            // Send the ghostlys off in random x and y directions! Wheee!
            ghostly.body.velocity.setTo(ghost.rnd.integerInRange(-50, 50), ghost.rnd.integerInRange(-50, 50), 0);
        }
    }
};

var spawnLittle = function () {
    var ghostly;
    for (var xx = 256; xx > 0; xx -= 100 ) {
        for (var yy = 256; yy > 0; yy -= 100 ) {
            // Create a ghostly using the new game.add.isoSprite factory method at the specified position.
            // The last parameter is the group you want to add it to (just like game.add.sprite)
            ghostly = ghost.add.isoSprite(50, 50, 400, 'ghostly', 0, ghosts);

            ghostly.anchor.set(0.5);

            // Enable the physics body on this ghostly.
            ghost.physics.isoArcade.enable(ghostly);

            // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
            ghostly.body.collideWorldBounds = true;

            // Add a full bounce on the x and y axes, and a bit on the z axis.
            ghostly.body.bounce.set(1, 1, 0.2);

            // Send the ghostlys off in random x and y directions! Wheee!
            ghostly.body.velocity.setTo(ghost.rnd.integerInRange(-100, 100), ghost.rnd.integerInRange(-100, 100), 0);
        }
    }
};


// game.state.add('Boot', BasicGame.Boot);
// game.state.start('Boot');
